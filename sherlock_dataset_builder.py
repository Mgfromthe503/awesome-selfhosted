"""Unified Sherlock training dataset builder."""

from __future__ import annotations

import json
from pathlib import Path
from typing import Any

from mm_language import run_mm_script
from sherlock_multimodal import SherlockVision

try:
    from alpha_mind_gamma_model import export_training_jsonl

    _HAS_ALPHA = True
except Exception:
    export_training_jsonl = None
    _HAS_ALPHA = False

try:
    from sherlock_training_data import emoji_translator, mm_emoji_knowledge_base, spiritual_meanings
except Exception:
    emoji_translator = {"ðŸ”¥": "fire", "ðŸ’§": "water", "ðŸ§ ": "brain"}
    spiritual_meanings = {"ðŸ”¥": "Transformation and energy", "ðŸ’§": "Emotion and intuition"}
    mm_emoji_knowledge_base = {
        "ðŸ”®": ("Crystal Ball", "Mysticism", "Divination symbol", "Represents foresight"),
        "ðŸ§ ": ("Brain", "Thinking", "Cognitive organ", "Represents intelligence"),
    }


def _emoji_records() -> list[dict[str, Any]]:
    records: list[dict[str, Any]] = []
    for symbol, desc in emoji_translator.items():
        records.append({"prompt": f"Translate emoji symbol: {symbol}", "completion": desc, "metadata": {"source": "emoji_translator"}})

    for symbol, meaning in spiritual_meanings.items():
        records.append({"prompt": f"What is the spiritual meaning of {symbol}?", "completion": meaning, "metadata": {"source": "spiritual_meanings"}})

    for symbol, entry in mm_emoji_knowledge_base.items():
        title, themes, literal, symbolic = entry
        records.append(
            {
                "prompt": f"Explain MM symbol {symbol}",
                "completion": f"{title}; themes={themes}; literal={literal}; symbolic={symbolic}",
                "metadata": {"source": "mm_emoji_knowledge_base"},
            }
        )

    return records


def _mm_language_records() -> list[dict[str, Any]]:
    script = """
# Sherlock MM language demo
ðŸ”® Correspondence
DETECT qubit IN quantum qubit entanglement report
ANOMALY SERIES: 1,1,2,1,1,10,1
TAG domain=bioinformatics
"""
    results = run_mm_script(script)
    return [{"prompt": "Execute MM script and summarize results.", "completion": json.dumps(results, ensure_ascii=False), "metadata": {"source": "mm_language"}}]


def _alpha_records(temp_path: Path) -> list[dict[str, Any]]:
    if not _HAS_ALPHA:
        return []
    export_path = export_training_jsonl(temp_path, size=120, seed=21, train_ratio=0.8)
    lines = Path(export_path).read_text(encoding="utf-8").splitlines()
    return [json.loads(line) for line in lines if line.strip()]


def _vision_records(image_paths: list[str] | None) -> list[dict[str, Any]]:
    if not image_paths:
        return []
    vision = SherlockVision()
    out: list[dict[str, Any]] = []
    for p in image_paths:
        out.append(vision.build_image_training_record(p, label="unknown_pattern", notes="autogenerated"))
    return out


def build_unified_training_dataset(
    out_path: str | Path = "data/processed/sherlock_unified_training.jsonl",
    *,
    include_alpha: bool = True,
    include_vision: bool = False,
    image_paths: list[str] | None = None,
) -> Path:
    out = Path(out_path)
    out.parent.mkdir(parents=True, exist_ok=True)

    records: list[dict[str, Any]] = []
    records.extend(_emoji_records())
    records.extend(_mm_language_records())

    if include_alpha:
        alpha_temp = out.parent / "alpha_tmp_records.jsonl"
        records.extend(_alpha_records(alpha_temp))

    if include_vision:
        records.extend(_vision_records(image_paths))

    with out.open("w", encoding="utf-8") as fh:
        for rec in records:
            fh.write(json.dumps(rec, ensure_ascii=False) + "\n")

    return out
